https://juejin.cn/post/6968713283884974088

## 模拟实现call
```js
// 必须在Function.prototype上实现, 且不能用箭头函数
Function.prototype.myCall = function(context, ...args) {
    const ctx = context || window; // 如果没有传参，则指向window
    ctx.func = this; // ctx.func只是一个名字，可以随便取。this是被调用的函数，因为函数调用call方法，call里面的this就指向那个函数。所以ctx.func就是那个函数。
    const result = ctx.func(...args); // 调用该方法并传入参数，此时该方法的this指向ctx
    delete ctx.func; // 删除该方法，不然会在传入的对象上添加这个方法。
    return result;
}
```

## 模拟实现apply
```js
Function.prototype.myApply = function(context, args = []) {
    const ctx = context || window;
    ctx.func = this; 
    const result = ctx.func(...args); // 跟call唯一的区别是参数不一样
    delete ctx.func;
    return result;
}
```

## 模拟实现bind
```js
Function.prototype.myBind = function(context, ...args) {
    const ctx = context || window;
    ctx.func = this; 
    return () => { // 跟call的区别是不立即执行，而是返回一个函数。
        const result = ctx.func(...args);
        delete ctx.func;
        return result;
    }
}
```

## 模拟实现new
```js
const myNew = (Constructor, ...args) => {
    let obj = {};
    obj.__proto__ = Constructor.prototype; // 不用主动指定obj.constructor
    let result = Constructor.apply(obj, args);
    // 判断构造函数的返回值类型，如果没有返回值或者返回值是值类型，返回obj这个新创建的实例（相当于this）。如果返回值时是引用类型比如return {x: 'a'}，就返回这个引用类型的对象。  
    return result instanceof Object ? result : obj;
}
```

## 模拟实现instanceof
```js
// instanceof 用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上
const myInstanceof = (instance, constructor) => {
    while(true) { 
        if(instance === null){ // 找到最顶层，原型链的最顶层是null
            return true;
        }
        if (instance.__proto__ === constructor.prototype) {
            return true;
        } 
        instance = instance.__proto__;
    }
}
```

## 实现深拷贝，可以克隆下面的对象
```js
let a = {
    a: {b: 'b'},
    c: () => { console.log('c') },
    d: [1,2],
    e: undefined,
    i: null,
    f: 1,
    K: true
}
a.g = a;
a.h = new Date();
```

```js
const deepClone = (obj) => {
    if (obj === null) return obj;
    if (obj instanceof Date) return new Date(obj);
    if (obj instanceof RegExp) return new RegExp(obj);

    let result;
    if (Object.prototype.toString.call(obj) === '[object Object]') {
        result = {}
        for(let key in obj) {
            // 对象并且循环引用
            if(Object.prototype.toString.call(obj[key]) === '[object Object]' && obj[key] === obj) {
                result[key] = result;
            } else {
                result[key] = deepClone(obj[key]); // 递归处理元素
            }
        }
    } else if (Object.prototype.toString.call(obj) === '[object Array]') {
        result = [];
        for(let item of obj) {
            result.push(deepClone(item)); // 递归数组元素
        }
    } else if (Object.prototype.toString.call(obj) === '[object Function]') {
        result = new Function("return " + obj)();
    } else {
        result = obj // 直接复制
    }
    return result
}
```

## 实现节流 throttle
```js
function throttle(method, delay) {
    let startTime = Date.now();
    return function() {
        const ctx = this // 要将this传递下去
        let currentTime = Date.now();
        if (currentTime - startTime >= delay) { // 靠两次运行的时间戳对比，时间没到不执行
            method.apply(ctx, arguments);
            startTime = currentTime;
        }
    }
}
const handle = () => {
    console.log('test');
}
const handleThrottle = throttle(handle, 1000)

window.addEventListener('scroll', handleThrottle);
```

## 实现防抖 debounce
```js
function debounce(method, delay) {
    let timer;
    return function() {
        const ctx = this // 要将this传递下去
        if(timer) clearTimeout(timer) // 靠setTimout等待一定的时间执行，时间未到，清空timer重新等待
        timer = setTimeout(() => { 
            method.apply(ctx, arguments)
        }, delay)
    }
}
const handle = () => {
    console.log('test');
}
const handleDebounce = debounce(handle, 1000)

window.addEventListener('scroll', handleDebounce);
```

## 实现Promise
```js
/*
    总结:
    1. 一个 class 类，有个constructor，参数是excutor，构造函数中执行这个excutor，excutor接受参数resolve， reject，用try catch包裹执行。
    2. 同时有4个实例属性，status, result, successCallbacks, errorCallbacks。
    3. 两个实例方法，then, catch。
    4. then里面判断状态，直接执行或者放入数组，因为要链式调用，所以返回的promise，等回调函数执行后才resolve
    5. catch中调用then
    */
class MyPromise{
    constructor(excutor) {
        this.status = 'pending';
        this.result = undefined;
        // 存放成功的回调
        this.successCallbacks = [];
        // 存放失败的回调
        this.errorCallbacks= [];

        let resolve = (result) => {
            if (this.status !== 'pending') return;
            this.status = 'fullfilled';
            this.result = result;
            // 依次将对应的函数执行
            this.successCallbacks.forEach(fn => fn.call(this, result));
        }

        let reject = (error) => {
            if (this.status !== 'pending') return;
            this.status = 'rejected';
            this.result = error;
            this.errorCallbacks.forEach(fn => fn.call(this, error));
        }

        try {
            excutor(resolve, reject)
        } catch(e){
            reject(e)
        }
    }

    then(success, error) {
        // 解决值穿透问题
        success = typeof success !== "function" ? (v) => v : success;
        error = typeof error !== "function" ? (err) => { throw err } : error;
        // 为了保持链式调用，继续返回promise
        return new MyPromise((resolve, reject) => {
            // 如果promise的状态是 pending，需要将 onFulfilled 和 onRejected 函数存放起来，等待状态确定后，再依次将对应的函数执行
            if (this.status === 'pending' && success) {
                this.successCallbacks.push((val) => {
                    try{
                        const res = success(val);
                        res instanceof MyPromise ? res.then(resolve, reject) : resolve(res);
                    } catch(e){
                        reject(e);
                    }
                });
            }
            if (this.status === 'pending' && error) {
                this.errorCallbacks.push((val) => {
                    try{
                        const res = error(val);
                        res instanceof MyPromise ? res.then(resolve, reject) : resolve(res);
                    } catch(e){
                        reject(e);
                    }
                });
            }
            if (this.status === 'fullfilled' && success) {
                try{
                    const res = success(this.result);
                    res instanceof MyPromise ? res.then(resolve, reject) : resolve(res);
                } catch(e){
                    reject(e);
                }
            }
            if (this.status === 'rejected' && error) {
                try{
                    const res = error(this.result);
                    res instanceof MyPromise ? res.then(resolve, reject) : resolve(res);
                } catch(e){
                    reject(e);
                }
            }
        })
    }
    catch(error) {
        return this.then(undefined, error);
    } 
}
```

## 自定义实现Promise.all
```js
const promiseAll = (promiseList) => {
    let result = [];
    let count = 0;
    return new Promise((resolve, reject) => {
        for(let i=0; i<promiseList.length; i++) {
            // 不能直接promiseList[i].then()， 因为promiseList[i]可能是普通数据
            Promise.resolve(promiseList[i]).then(res => {
                count++;
                result[i] = res;
                if (count === promiseList.length) {
                    resolve(result);
                }
            }).catch(e => {
                reject(e)
            })
        }
    })
}
```

## 实现一个带并发限制的异步调度器 `Scheduler`，保证同时运行的任务最多有两个。
```js
class Scheduler {
    add(promiseCreator) { ... }
    // ...
}

const timeout = (time) => new Promise(resolve => {
    setTimeout(resolve, time)
})

const scheduler = new Scheduler()
const addTask = (time, order) => {
    scheduler.add(() => timeout(time)).then(() => console.log(order))
}

addTask(1000, '1')
addTask(500, '2')
addTask(300, '3')
addTask(400, '4')

// 打印顺序是：2 3 1 4
// 一开始，1、2两个任务进入队列
// 500ms时，2完成，输出2，任务3进队
// 800ms时，3完成，输出3，任务4进队
// 1000ms时，1完成，输出1
// 1200ms时，4完成，输出4
```

```js
/*
    1. add方法要返回一个promise，如果执行的数量<2，要执行promise，否则放入list
    2. add方法的resolve，要在promise执行之后，所以要将resolve传下去
    3. 执行方法中执行promise，控制count，并检查list中是否还有未执行的promise
*/
class Scheduler {
    constructor() {
        this.max = 2;
        this.count = 0;
        this.list = [];
    }
    add(promise) { 
        return new Promise((resolve) => {
            promise.end = resolve;
            if (this.count < this.max) {
                this.excute(promise)
            } else {
                this.list.push(promise)
            }
        })
    }
    async excute(promise) {
        this.count++;
        await promise();
        promise.end()
        this.count--;
        if(this.list.length) {
            this.excute(this.list.shift())
        }
    }
}
```

## 实现一个对象的flatten方法，将层级嵌套的属性拉平
```js
const obj = {
    a: {
        b: 1,
        c: 2,
        d: { e: 5 }
    },
    b: [1, 3, { a: 2, b: 3 }],
    c: 3
}

flatten(obj) 
// 结果返回如下
// {
//     'a.b': 1,
//     'a.c': 2,
//     'a.d.e': 5,
//     'b[0]': 1,
//     'b[1]': 3,
//     'b[2].a': 2,
//     'b[2].b': 3
//     c: 3
// }
```

```js
const flatten = (obj) => {
    let result = {};
    const dfs = (current, prefix) => {
        if(Object.prototype.toString.call(current) === '[object Object]') {
            for (const key in current) {
                // 对象的前缀
                result = dfs(current[key], `${prefix}${prefix ? '.' : ''}${key}`);
            }
        } else if (Object.prototype.toString.call(current) === '[object Array]'){
            current.forEach((item, index) => {
                // 数组的前缀
                result = dfs(item, `${prefix}[${index}]`);
            });
        } else {
            result[prefix] = current;
        }
        return result;
    }

    return dfs(obj, '')    
}
```

## 实现一个方法，将平级的对象转成层级嵌套对象
```js
const obj = {
    'a.b': 1,
    'a.c': 2,
    'a.d.e': 5,
    'a.d.f': 6,
    c: 3
}
convert(obj) 
// 结果返回如下
// {
//     a: {
//         b: 1,
//         c: 2,
//         d: { 
//             e: 5,
//             f: 6
//         }
//     },
//     c: 3
// }
```

```js
const convert = (obj) => {
    let result = {};
    const keys = Object.keys(obj);
    keys.forEach(key => {
        const arr = key.split('.');
        // 嵌套的多级
        if(arr.length > 1) {
            arr.reduce((prev, next, index) => {
                // 如果目标对象不存在该子级，应该给该子级赋值。赋值为最终值或者新的对象
                if(!prev[next]) {
                    if(index === arr.length-1) {
                        prev[next] = obj[key]
                    } else {
                        prev[next] = {}
                    }
                } 
                return prev[next]
            }, result)
        } else { // 只有一级
            result[arr[0]] = obj[key];
        }
    })

    return result;
}
```

## 实现一个数组的flatten方法

## 实现一个数组的reduce方法

## 实现一个curry函数，可以满足下面的逻辑
```js
const sum = (a, b, c) => a + b + c
const fn = curry(sum);

fn(1, 2, 3); // 6
fn(1, 2)(3); // 6
fn(1)(2, 3); // 6
fn(1)(2)(3); // 6
```

```js
const curry = fn => {
    /*
        思路解析：
        1. 接受一个原函数，返回一个柯里化后的函数
        2. 如果柯里化后的函数接受的参数个数大于等于原函数的参数个数，直接调用原函数，返回结果
        3. 否则的话，说明参数还未接受完毕，返回一个函数，继续接受新的参数，旧参数+新的参数 去递归
    */
    const nest = (...args) => {
        if (args.length >= fn.length) {
            return fn(...args);
        } else {
            return (...restArgs) => {
                return nest(...[...args, ...restArgs]);
            }
        }
    }
    return nest;
}
```

## 实现一个函数sum，接受多个参数，sum(a)(b)(c)...(n)()，返回a到n的和。
```js
const sum = (a) => {
    // 返回一个函数，如果没有参数就返回当前值，有参数就递归
    return (x) => {
        if (x) {
            return sum(a + x);
        } else {
            return a
        }
    }
}
```

## 实现一个函数sum，接受多个参数，sum(a)(b)(c)...(n).count()，调用count()返回a到n的和。
```js
const sum = (a)=> {
    let args = [a];

    const add = (x) => {
        args.push(x);
        return add
    }

    add.count = () => {
        return args.reduce((total, next) => {
            return total + next;
        }, 0);
    };

    return add;
}
```

## 实现一个compose函数，它接受任意多个函数作为参数（这些函数都只接受一个参数），然后compose返回的也是一个函数，达到以下的效果：
```js
const add1 = (x) => x + 1;
const mul3 = (x) => x * 3;
const div2 = (x) => x / 2;
div2(mul3(add1(add1(0)))); // => 3

const operate = compose(div2, mul3, add1, add1)
operate(0) // => 3 相当于div2(mul3(add1(add1(0)))) 
operate(2) // => 6 相当于div2(mul3(add1(add1(2))))
// compose(f,g)(x) === f(g(x))
// compose(f,g,m)(x) === f(g(m(x)))
// compose(f,g,m)(x) === f(g(m(x)))
// compose(f,g,m,n)(x) === f(g(m(n(x))))
```

```js
const compose = (...args) => {
    return (x) => {
        return args.reduceRight((prev, next) => { // reduceRight，从右向左执行。不能用args.reverse().reduce，会改变args参数，每次执行会不一样
            return next(prev)
        }, x)
    }
}
const compose = (...args) => {
    const temp = args.reverse();
    return (x) => {
        return temp.reduce((prev, next) => { 
            return next(prev)
        }, x)
    }
}
```

## setTimeout 模拟实现 setTnterval(带清除定时器的版本)
```js
function mySetInterval(fn, delay) {
    let timer;
    const interval = () => {
        timer = setTimeout(() => {
            fn();
            interval();
        }, delay);
    }
    interval()
    return () => clearTimeout(timer)
    }
}

let cancel = mySetInterval(() => {
    console.log(2)
}, 1000)

cancle();
```

## 实现发布订阅模式

## 继承和原型链
```js
// ES5组合寄生继承
var Father = function() {
    this.name = '爸爸';
}

var Son = function() {
    Father.call(this);
    this.name = '儿子';
}
Son.prototype = Object.create(Father.prototype);
Son.prototype.constructor = Son;
var son = new Son();

// ES6继承
class Father {
    constructor() {
        this.name = '爸爸';
    }
}
class Son extends Father {
    constructor() {
        super();
        this.name = '儿子';
    }
}
var son = new Son();

// 实例的，父类的prototype.__proto__直接指向Object.prototype
console.log(son.__proto__ === Son.prototype)
console.log(Son.prototype.__proto__ === Father.prototype)
console.log(Father.prototype.__proto__ === Object.prototype)
console.log(Object.prototype.__proto__ === null)

// 类的，类的__proto__属性指向父类，没有父类或者ES5中指向Function.prototype
console.log(Son.__proto__ === Father) // ES5指向Function.prototype
console.log(Father.__proto__ === Function.prototype)
console.log(Function.prototype.__proto__ === Object.prototype)
console.log(Object.prototype.__proto__ === null)
```

## 变量提升相关，问输出
```js
/*
    1. var变量声明 和 函数声明都会变量提升
    2. 函数声明是整体提升，优先级高于var声明，且直接赋值
    3. 具体的执行是什么取决于赋值是什么。
*/
function Foo() {
    log = function () {
        console.log(1);
    };
    return this;
}
Foo.log = function () {
    console.log(2);
};
Foo.prototype.log = function () {
    console.log(3);
};
var log = function () {
    console.log(4);
};
function log() {
    console.log(5);
}

Foo.log(); // 2
log(); // 4
Foo().log(); // 1
log(); // 1
new Foo.log(); // 2
new Foo().log(); // 3
```

## this指向问题，问输出
```js
var x = 0;
var obj = {
    x: 10,
    bar() {
        var x = 20;
        console.log(this.x);
    }
}

obj.bar() // 10
var foo = obj.bar;
foo() // 0
obj.bar.call(window) // 0
obj.bar.call(obj) // 10
foo.call(obj) // 10
```

## 事件循环相关，问输出
```js
console.log(1)
setTimeout(()=> {
    console.log(2)
}, 1000)
setTimeout(() => {
    var p = new Promise((resolve, reject) => {
        console.log(3)
        resolve()
    }).then(() => {
        console.log(4)
    })
    Promise.resolve().then(() => {
        console.log(5)
    })
}, 0)
setTimeout(() => {
    Promise.resolve().then(() => {
        console.log(6)
    })
}, 0)
new Promise((resolve, reject) => {
    console.log(7)
    resolve()
}).then(() => {
    console.log(8)
})
Promise.resolve().then(() => {
    console.log(9)
})
async function async1() {
    await async2()
    console.log(10)
}
async function async2() {
    await async3()
    console.log(11)
}
async function async3() {
    console.log(12)
}
async1()
console.log(13)

// 1, 7, 12, 13, 8, 9, 11, 10, 3, 4, 5, 6, 2
```

## 用React hook实现一个计数器组件
```js
fucntion Counter() {
  const [count, setCount] = useState(0);
  useEffect(() => {
    const timer = setInterval(() => {
      setCount(count => count+1)
    }, 1000)
  },[])
  return () => {
    clearInterval(timer)
  }
}
```

## 如何实现一个自定义hook，useEventListener
```js
function useEventListener(eventName, handler, dom) {
  const savedHandler = useRef();

  useEffect(() => {
    savedHandler.current = handler;
  }, [handler]);

  useEffect(() => {
    const eventListener = (event) => savedHandler.current(event);
    dom.addEventLister(eventName, eventListener);
    return () => {
      dom.removeEventListener(eventName, eventListener);
    }
  }, [eventName, dom])
}
```

## Proxy
```js
var target = {}
var proxy = new Proxy(target, {
    set(target, property, value, receiver) {
        console.log(target);
        console.log(property);
        console.log(value);
        console.log(receiver);
        Reflect.set(target, property, value, receiver);
    },
    get(target, property, receiver) {
        console.log(target);
        console.log(property);
        console.log(receiver);
        return Reflect.get(target, property, receiver);
    }
})
```

## webpack loader plugin

## 排序

## Map，哈希表

## 栈，队列

## 双指针

## 滑动窗口

## 递归

## DFS, BFS
