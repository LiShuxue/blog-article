## 微信公众号

微信公众号是最早推出的，分为订阅号和服务号两种类型。订阅号主要面向媒体和个人，用于内容传播和粉丝互动；服务号则主要面向企业和组织，提供更高级的服务功能，如微信支付、用户管理等。

微信公众号的出现满足了企业和个人通过微信平台接触用户的需求，它使得信息发布变得更加便捷，并迅速成为企业进行品牌宣传和用户运营的重要工具。通过微信公众号，用户可以获取新闻资讯、产品信息，甚至进行一些简单的在线服务，如查询、支付等。

## 小程序诞生背景

尽管微信公众号在初期取得了巨大成功，但随着时间的推移，一些局限性逐渐显现：

- 用户体验受限: 公众号主要是基于 H5 技术（通过[微信 JS-SDK](https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html)与原生交互），页面的加载速度，受限于设备性能和网络速度，导致用户体验不如原生 App 流畅。

- 功能单一: 公众号的主要功能是信息传播和简单的服务调用，无法实现复杂的应用场景。

- 无法离线使用: 公众号的内容和服务都依赖于网络连接，无法提供离线访问的能力。

为了克服这些局限性，同时应对移动互联网时代用户对轻量级、便捷应用的需求，微信团队开始构思和开发微信小程序。目的是提供一种介于原生 App 和 H5 网页之间的轻量级应用形态。

微信小程序于 2017 年 1 月正式推出，小程序不仅弥补了公众号在应用场景上的不足，还为微信平台带来了更多的创新和可能性。

- 提升用户体验: 小程序具有更好的性能和加载速度，接近于原生 App 的体验。此外，小程序支持离线缓存和后台运行，用户可以在断网或弱网环境下继续使用

- 简化开发流程: 小程序提供了一套统一的开发框架和组件库，同时还可以通过微信平台的 API 实现更深度的功能整合，如支付、位置服务等。

- 丰富的应用场景: 小程序的出现扩展了微信生态系统的应用场景，从内容传播扩展到电商、游戏、生活服务等多个领域。

## 小程序的现状

微信小程序的用户规模已经非常庞大。截至 2024 年，微信小程序的月活跃用户数量已超过 10 亿。并且在多个行业和场景中得到广泛应用，如电子商务，生活服务（衣食住行），金融服务，娱乐与社交，政务与公共服务等。成为了用户日常生活中不可或缺的一部分。

这种模式也引发了其他互联网巨头的效仿，催生了多种小程序平台。支付宝、美团，京东，百度，字节等都纷纷推出了自己的小程序平台，各大超级 App 通过集成小程序，打造出了一个“超级 App + 小程序”的全新应用生态。

## 架构演进

### V1：早期 JSBridge

早期在微信内部就希望在微信打开的 H5 可以调用到原生一些能力，所以早期微信提供了 Webview 到原生的通信机制，在 Webview 里注入 JSBridge 的接口，使得 H5 可以通过它调用到原生能力。

![v1](https://cdn.lishuxue.site/blog/image/小程序/v1.png)

### V2：JSSDK

早期微信官方是没有暴露这些接口的，都是腾讯内部业务在使用，很多外部开发者发现后，就依葫芦画瓢地使用了。所以在 2015 年初的时候，微信就发布了 JSSDK，其实就是隐藏了内部一些细节，包装了几十个 API 给到上层业务直接调用。

![v2](https://cdn.lishuxue.site/blog/image/小程序/v2.png)

### V3：本地资源

采用 hybrid 的方式，把 H5 所有代码打包，一次性 Load 到本地再打开。这样的好处是我们可以用一种近似 Web 的方式来开发，同时在体验上也可以做到不错的效果，并且也是可以做到云端更新。

![v3](https://cdn.lishuxue.site/blog/image/小程序/v3.png)

### V4：双线程

把开发者的 JS 逻辑代码放到单独的线程去运行，因为不在 Webview 线程里，所以这个环境没有 Webview 任何接口，自然的开发者就没法直接操作 Dom，也就没法动态去更改界面，“管控”的问题得以解决。

如果用户交互需要界面变化的话，就需要不直接操作 Dom 也能做到界面更新，类似 Virtual Dom 的概念，业务侧只需要改变数据即可引起界面变化

至此小程序双线程的模型就定下来了：渲染层(Webview)+逻辑层(JSCore)

![v4-1](https://cdn.lishuxue.site/blog/image/小程序/v4-1.png)

渲染层提供了带有数据绑定语法的 WXML，逻辑层提供了 setData 等等 API，开发者需要进行界面变化时，只需要通过 setData 把变化的数据传进去，小程序框架就会进行 Dom Diff 等流程最后把正确的结果更新在 Dom 树上。

![v4-2](https://cdn.lishuxue.site/blog/image/小程序/v4-2.png)

在开发者的逻辑下层，还需要有一层小程序框架的支持（数据通信、API、VD 算法等等），我们把它称为基础库。

两个线程各自注入了一份基础库，渲染层的基础库含有 VD 的处理以及底层组件系统的机制，对上层提供一些内置组件，例如 video、image 等等。逻辑层的基础库主要会提供给上层一些 API，例如大家经常用到的 wx.login、wx.getSystemInfo 等等。

### V5：同层渲染

用户在屏幕点击某个按钮，需要视图层先发给 native，native 告诉逻辑层，逻辑层在处理数据，发给 native，native 再让视图层变化。整个过程需要四次通信。对于一些强交互（例如拖动视频进度条）的场景，这样的处理流程会导致用户的操作很卡。

对于这种强交互的场景，引入了原生组件，这样用户和原生组件的交互可以节省两次通信。

![v5](https://cdn.lishuxue.site/blog/image/小程序/v5.png)

## 页面执行逻辑

![luoji](https://cdn.lishuxue.site/blog/image/小程序/luoji.png)

小程序在 Page 渲染和 Component 渲染时通信方式上存在差别。其中，Page 渲染中 VDOM 的生成和 diff 都是在视图层完成的，逻辑层只负责对 data 数据的发送，来触发渲染层的更新逻辑。而在 Component 的渲染中，逻辑层和视图层需要共同维护一套 VDOM，方式则是在组件初始化时在逻辑层构建组件的 VDOM，然后将其同步到视图层。后续的更新操作则会先在逻辑层进行新旧 VDOM 的 diff，然后仅将 diff 之后的结果进行通信，传递到视图层之后直接进行 VDOM 的更新和渲染。这样做最大的好处就是将视图更新通信的粒度控制成 DOM 级别，只有最终发生改变的 DOM 才会被更新过去（因为有时候 data 的改变并不一定会带来视图的更新），相对于之前 data 级别的更新会更加精准，避免非必要的通信成本，性能更好。

## 为什么是 WXML

在小程序的双线程架构中，逻辑层和渲染层是分离的。逻辑层运行在 JavaScript 线程中，而渲染层运行在 WebView 线程中。因为逻辑层无法直接操作渲染层的 DOM，所以需要一种机制来在逻辑层与渲染层之间进行数据传递和界面更新。

1. 基于数据驱动的更新。类似目前所有的比较火的框架，我们通过改变 data 的方式，来使视图更新 UI=f(data)，所以需要有 setData 的逻辑。

2. 仅更新实际需要变更的部分 DOM。需要引入虚拟 DOM 的逻辑。

3. 事件的处理。用户在界面上的点击按钮、输入文字等，会首先在渲染层（WebView）中被捕获。渲染层中的每个组件都绑定了特定的事件监听器，将事件的相关信息（如事件类型、触发位置、组件 ID 等）封装成一个事件对象。通过小程序框架提供的底层机制传递给逻辑层。逻辑层接收到事件对象后，会根据事件类型和目标组件 ID 等信息，触发相应的事件处理逻辑。

4. 数据回传到渲染层。在逻辑层处理完后，需要通过 setData 等 API 将新的数据发送回渲染层。

基于上面的因素，所以腾讯设计了一个新的框架和 DSL，基于 WXML 和 WXSS，WXS 等。

## 参考

<https://juejin.cn/post/6991721372779020295>

<https://rapidsu.cn/articles/360>

<https://github.com/LiShuxue/hera>
