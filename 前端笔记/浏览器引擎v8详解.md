## 什么是 V8

[V8](https://v8.dev/docs) 是 Google 开源的高性能 JavaScript 和 WebAssembly 引擎，用 C++ 编写。被广泛应用于各种需要执行 Javascript 的环境中，如 Chrome 和 Node.js 等。V8 可以独立运行，也可以嵌入到任何 C++ 应用程序中。

## 为什么需要 JavaScript 引擎

我们写的 JavaScript 代码直接交给浏览器或者 Node 执行时，底层的 CPU 是不认识的，也没法执行。CPU 只认识自己的指令集对应的二进制代码，并且不同类型的 CPU 的指令集是不一样的。

JavaScript 引擎可以将 JS 代码编译为不同 CPU(Intel, ARM 以及 MIPS 等)对应的二进制代码执行。

## 都有哪些常见的 JS 引擎

- Mozilla 的 SpiderMonkey 引擎
- Apple 的 JavaScriptCore
- Google 的 V8 引擎
- JerryScript 引擎，嵌入式设备的小型 JavaScript 引擎
- Nashorn 引擎，Java 的嵌入式 JavaScript 引擎
- Hermes 引擎，解析 React Native 代码
- QuickJS 引擎，是一个小型并且可嵌入的 Javascript 引擎

### 字节码，机器码，汇编代码

- 机器码：该机器的 CPU 对应的二进制 01 代码。
- 字节码：V8 将源码转换成的一种中间代码，语法类似汇编。只是它没有对应特定的 CPU。
- 汇编代码：汇编代码可以借助汇编器转化为二进制 01 代码，供 CPU 执行。不同的 CPU 需要不同的汇编，比如 Intel 和 ARM 的汇编就不一样：汇编的指令集不一样，指令格式不一样，寻址方式也不一样。

```js
# 将一个寄存器中的数据移动到另外一个寄存器中
1000100111011000  # 机器码
mov ax,bx         # 汇编代码
```

JS 引擎先生成字节码，直接解释执行（执行的时候需要转为机器码），或者经过优化转为汇编代码，再转成机器码供 CPU 执行。

## V8 的作用是什么

V8 主要用来编译和执行 JavaScript 源代码，处理对象的内存分配，以及垃圾回收它不再需要的对象。

V8 提供了 ECMA 标准中指定的所有数据类型、运算符、对象和函数。DOM 对象不是 V8 提供的，是浏览器提供的。

## V8 的最新架构

![v8](https://cdn.lishuxue.site/blog/image/前端笔记/v8.png)
![v8-flow](https://cdn.lishuxue.site/blog/image/前端笔记/v8-flow.png)

### 解析器 Parser

负责将 JavaScript 源码转换为 抽象语法树 AST。通过词法分析，生成 tokens，通过语法分析，根据 tokens 生成 AST 抽象语法树。

V8 的整个解析过程是流（Stream）化的，也就是一边从网络下载源代码，一边解析。在下载后，各种不同的编码还被统一转化为 UTF-16 编码单位，这样词法解析器就不需要处理多种编码了。

#### 延迟解析（懒解析）

遇到函数，只会对其进行预解析(Pre-Parser)，验证函数的语法是否有效、解析函数声明以及确定函数作用域，并不会生成 AST，当函数被调用时，才会对其完全解析。这也叫延迟解析。

### 解释器 Ignition

负责将 AST 转换为 Bytecode，再执行 Bytecode（执行时也是需要转换为机器码的）。同时标记重复执行的热点代码，丢给编译器优化。

### 优化编译器 TurboFan

利用 Ignition 所收集的信息，将 Bytecode 转换为优化后的机器码。当该段代码再次执行时，解释器就直接使用该机器码执行，不用再次解释。同时也会反优化解释器。

#### 反优化

优化后的 机器码 会被还原为 Bytecode，这个过程叫做反优化。这是因为 Ignition 收集的信息可能是错误的，比如函数的参数之前是整数，后来又变成了字符串。生成的 机器码 已经假定函数的参数是整数，那当然是错误的，于是需要进行 反优化。

### 解释执行

需要先将输入的源代码通过解析器编译成中间代码，之后直接使用解释器解释执行中间代码，然后直接输出结果。

### 编译执行

先将源代码转换为中间代码，然后我们的编译器再将中间代码编译成机器代码。通常编译成的机器代码是以二进制文件形式存储的，需要执行这段程序的时候直接执行二进制文件就可以了。

#### 编译执行、解释执行、即时编译

C 语言编译器 gcc，Java 语言编译器 javac。

编译执行：通过编译器将源代码编译成机器码，之后才能执行的语言。比如 C 语言。

解释执行：不需要预先进行编译，逐行解释执行。比如最早期的 js 和 java

即时编译(JIT)：现在 V8 中，js 这种在运行时编译代码的技术也被称为 JIT（即时编译）。

### 垃圾回收器 Orinoco

垃圾回收模块，负责将程序不再需要的内存空间回收。

## V8 怎么执行 JavaScript 代码的？

- 初始化堆栈空间，事件循环系统。
- 解析源码生成 AST 和 全局上下文（作用域），全局上下文入栈；
- 依据 AST 和作用域生成字节码；
- 解释执行字节码，遇见函数，解析函数 AST，创建函数上下文（作用域），函数上下文入栈；
- 监听热点代码；
- 优化热点代码为机器代码；
- 反优化生成的机器代码。

## 解释器（Ignition）如何将 AST 翻译为字节码并执行？

一份源码，直接转换成机器码，体积是很大的，非常消耗内存，V8 为了解决内存占用问题引入了字节码，先将源码转换成字节码。

V8 的字节码是对机器码的抽象，语法与汇编有些类似。可以把 V8 字节码看作一个个指令，这些指令组合到一起实现我们编写的功能，V8 定义了几百个字节码，可以在 V8 解释器的头文件中查看所有字节码。

通常有两种类型的解释器，基于栈 (Stack-based)和 基于寄存器 (Register-based)。

- 基于栈的解释器：使用栈来保存函数参数、中间运算结果、变量等
- 基于寄存器的解释器：支持寄存器的指令操作，使用寄存器来保存参数、变量、中间计算结果等

通常，基于栈的虚拟机也定义了少量的寄存器，基于寄存器的虚拟机也有堆栈，其区别体现在它们提供的指令集体系。V8 虚拟机则采用了基于寄存器的设计。

解释器在执行字节码时，主要使用通用寄存器和累加寄存器，函数参数和局部变量都保存在通用寄存器中，累加寄存器用于保存中间结果。字节码来控制各种寄存器的执行，最终返回输出。

## 优化编译器（TurboFan）的工作原理

如果函数没有被调用，则 V8 不会去编译它。如果函数只被调用 1 次，则 Ignition 将其编译 Bytecode 就直接解释执行了。TurboFan 不会进行优化编译，因为它需要 Ignition 收集函数执行时的类型信息。这就要求函数至少需要执行 1 次，TurboFan 才有可能进行优化编译。

如果函数被调用多次，则它有可能会被识别为热点函数，且 Ignition 收集的类型信息证明可以进行优化编译的话，这时 TurboFan 则会将 Bytecode 编译为 Optimized Machine Code（已优化的机器码），以提高代码的执行性能。

V8 为了提升 JavaScript 的执行性能，在优化编译方面做了很多工作，其中最主要有内联和逃逸分析两种算法。

## V8 调试 v8-debug / d8

v8-debug / d8 是一个非常有用的调试工具，我们可以使用它来查看 V8 在执行 JavaScript 过程中的各种中间数据，比如作用域、AST、字节码、优化的二进制代码、垃圾回收的状态等等。

### 通过 jsvu 安装 v8-debug

jsvu 是 JavaScript 引擎版本管理工具，可以安装不同的 js 引擎。

```
npm install -g jsvu
```

执行 jsvu，根据提示安装 V8 和 V8 debug 包，安装后将在用户目录下的 `.jsvu` 文件夹下

```
jsvu
```

### 用法

先将命令输出到一个文本中，方便查阅

```js
~/.jsvu/v8-debug --help >> v8-debug-help.txt
```

比如有一个 js 文件

```js
function add(a, b) {
  return a + b;
}
for (i = 0; i < 100000; i++) {
  add(i, i + 1);
}
```

- --print-scopes // 打印作用域信息
- --print-ast // 打印 AST 语法树
- --print-bytecode // 打印生成的字节码
- --print-opt-source // 打印优化后的源码
- --print-opt-code // 打印优化后的汇编代码
- --trace-gc // 打印内存回收信息

## 执行上下文 & 作用域

### 执行上下文

执行上下文其实就是当代码执行时的 context，包含词法环境，变量环境，以及 this 的指向。共有三种：

- 全局执行上下文
- 函数执行上下文
- eval 执行上下文

伪代码：

```js
GlobalExectionContext = {
  // this value
  ThisBinding: xxxx,
  // 词法环境
  LexicalEnvironment: {
    // ...
  },
  // 变量环境
  VariableEnvironment: {
    //...
  },
};

FunctionExectionContext = {
  // ...
};
```

#### 词法环境 & 变量环境

一个词法环境由环境记录器和一个可能的引用外部词法环境的引用组成。

- 环境记录器是存储 let const 类型的变量和函数声明等。
- 外部环境的引用意味着它可以访问其父级词法环境。全局环境的外部环境引用是 null。

变量环境：它同样是一个词法环境，只用来存储 var 类型的变量或者函数声明

伪代码

```js
// 全局上下文
GlobalExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      // 在这里绑定标识符
    }
    outer: null
  }
}

FunctionExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      // 在这里绑定标识符
    }
    outer: xxxx // 全局或者外部词法环境的引用
  }
}
```

### 作用域 & 作用域链

词法环境和变量环境组成了作用域，在代码执行过程中，会从这些环境中寻找对应的变量，找不到就从父级环境找，形成作用域链。

### 函数调用栈

栈里面存储的就是函数的调用信息，比如函数本身，函数参数，以及函数的执行上下文。所以我们调试的时候查看不同阶段的 call stack 可以看到当时的参数等信息。

在代码执行阶段，先将全局代码和全局执行上下文放入函数调用栈栈底，然后执行函数，如果执行中遇到别的函数，在将局部函数及上下文放入栈。处于栈顶的函数执行完毕之后，就会自动出栈。

## 内存管理

程序运行的时候，操作系统会给它分配一段内存，用来储存程序和运行产生的数据。这段内存有起始地址和结束地址，比如从 0x1000 到 0x8000，起始地址是较小的那个地址，结束地址是较大的那个地址。

### 堆

程序运行过程中，对于动态的内存占用请求（例如数组对象、object 对象），系统就会从预先分配好的那段内存之中，划出一部分给用户。这种因为用户主动请求而划分出来的内存区域，叫做 Heap（堆）。它由起始地址开始，从低位（地址）向高位（地址）增长。Heap 的一个重要特点就是不会自动消失，必须手动释放，或者由垃圾回收机制来回收。

### 栈

除了堆以外，其他的内存占用叫做 Stack（栈）。由内存区域的结束地址开始，从高位（地址）向低位（地址）分配。简单说，Stack 是由于函数运行而临时占用的内存区域。主要存放一些基本类型的变量和对象的引用。

### 垃圾回收

对于栈的内存空间，只保存简单数据类型的内存，由操作系统自动分配和自动释放。而堆空间中的内存，由于大小不固定，系统无法无法进行自动释放，这个时候就需要 JS 引擎来手动的释放这些内存。

在 JavaScript 中，其实绝大多数的对象存活周期都很短，大部分在经过一次的垃圾回收之后，内存就会被释放掉，而少部分的对象存活周期将会很长，一直是活跃的对象，不需要被回收。为了提高回收效率，V8 将堆分为两类新生代和老生代，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。

新生区通常只支持 1 ～ 8M 的容量，而老生区支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。

- 副垃圾回收器 - Scavenge：主要负责新生代的垃圾回收。
- 主垃圾回收器 - Mark-Sweep & Mark-Compact：主要负责老生代的垃圾回收。

#### 新生代垃圾回收器 - Scavenge

在 JavaScript 中，任何对象的声明分配到的内存，将会先被放置在新生代中，而因为大部分对象在内存中存活的周期很短，所以需要一个效率非常高的算法。

Scavange 算法将新生代堆分为两部分，分别叫 from-space 和 to-space，工作方式也很简单，就是将 from-space 中存活的活动对象复制到 to-space 中，并将这些对象的内存有序的排列起来，然后将 from-space 中的非活动对象的内存进行释放，完成之后，将 from space 和 to space 进行互换，这样可以使得新生代中的这两块区域可以重复利用。

在新生代中，还进一步进行了细分，分为 nursery 子代和 intermediate 子代两个区域，一个对象第一次分配内存时会被分配到新生代中的 nursery 子代，如果进过下一次垃圾回收这个对象还存在新生代中，这时候我们移动到 intermediate 子代，再经过下一次垃圾回收，如果这个对象还在新生代中，副垃圾回收器会将该对象移动到老生代中，这个移动的过程被称为晋升。

#### 垃圾回收器是怎么知道哪些对象是活动对象和非活动对象的呢？

有一个概念叫对象的可达性，表示从初始的根对象（window，global）的指针开始，这个根指针对象被称为根集（root set），从这个根集向下搜索其子节点，被搜索到的子节点说明该节点的引用对象可达，并为其留下标记，然后递归这个搜索的过程，直到所有子节点都被遍历结束，那么没有被标记的对象节点，说明该对象没有被任何地方引用，可以证明这是一个需要被释放内存的对象，可以被垃圾回收器回收。

#### 老生代垃圾回收 - Mark-Sweep & Mark-Compact

Mark-Sweep 处理时分为两阶段，标记阶段和清理阶段，看起来与 Scavenge 类似，不同的是，Scavenge 算法是复制活动对象，而由于在老生代中活动对象占大多数，所以 Mark-Sweep 在标记了活动对象和非活动对象之后，直接把非活动对象清除。

- 标记阶段：对老生代进行第一次扫描，标记活动对象
- 清理阶段：对老生代进行第二次扫描，清除未被标记的对象，即清理非活动对象

看似一切 perfect，但是还遗留一个问题，被清除的对象遍布于各内存地址，产生很多内存碎片。

为了解决内存碎片问题，Mark-Compact 被提出，它是在是在 Mark-Sweep 的基础上演进而来的，相比 Mark-Sweep，Mark-Compact 添加了活动对象整理阶段，将所有的活动对象往一端移动，移动完成后，直接清理掉边界外的内存。
