## 什么是V8 
[V8](https://v8.dev/docs) 是 Google 开源的高性能 JavaScript 和 WebAssembly 引擎，用 C++ 编写。被广泛应用于各种需要执行 Javascript 的环境中，如 Chrome 和 Node.js 等。V8 可以独立运行，也可以嵌入到任何 C++ 应用程序中。

## 为什么需要 JavaScript 引擎
我们写的 JavaScript 代码直接交给浏览器或者 Node 执行时，底层的 CPU 是不认识的，也没法执行。CPU 只认识自己的指令集对应的二进制代码，并且不同类型的 CPU 的指令集是不一样的。

JavaScript 引擎可以将 JS 代码编译为不同 CPU(Intel, ARM 以及 MIPS 等)对应的二进制代码执行。

### 字节码，机器码，汇编代码
* 机器码：该机器的CPU对应的二进制01代码。
* 字节码：V8将源码转换成的一种中间代码，语法类似汇编。只是它没有对应特定的CPU。
* 汇编代码：汇编代码可以借助汇编器转化为二进制01代码，供CPU执行。不同的CPU需要不同的汇编，比如Intel和ARM的汇编就不一样：汇编的指令集不一样，指令格式不一样，寻址方式也不一样。

```js
# 将一个寄存器中的数据移动到另外一个寄存器中
1000100111011000  # 机器码
mov ax,bx         # 汇编代码
```

JS引擎先生成字节码，直接解释执行（执行的时候需要转为机器码），或者经过优化转为汇编代码，再转成机器码供CPU执行。

## V8的作用是什么
V8 主要用来编译和执行 JavaScript 源代码，处理对象的内存分配，以及垃圾回收它不再需要的对象。

V8 提供了 ECMA 标准中指定的所有数据类型、运算符、对象和函数。DOM 对象不是V8提供的，是浏览器提供的。

## V8的最新架构
![v8](https://raw.githubusercontent.com/LiShuxue/blog-article/master/面试/v8.png)
![v8-flow](https://raw.githubusercontent.com/LiShuxue/blog-article/master/前端笔记/v8-flow.png)
### 解析器 Parser
负责将 JavaScript 源码转换为 抽象语法树 AST。通过词法分析，生成tokens，通过语法分析，根据tokens生成AST抽象语法树。

V8 的整个解析过程是流（Stream）化的，也就是一边从网络下载源代码，一边解析。在下载后，各种不同的编码还被统一转化为 UTF-16 编码单位，这样词法解析器就不需要处理多种编码了。

#### 延迟解析（懒解析）
遇到函数，只会对其进行预解析(Pre-Parser)，验证函数的语法是否有效、解析函数声明以及确定函数作用域，并不会生成 AST，当函数被调用时，才会对其完全解析。这也叫延迟解析。

### 解释器 Ignition
负责将 AST 转换为 Bytecode，再执行 Bytecode（执行时也是需要转换为机器码的）。同时标记重复执行的热点代码，丢给编译器优化。

通常有两种类型的解释器，基于栈 (Stack-based)和 基于寄存器 (Register-based)。
* 基于栈的解释器：使用栈来保存函数参数、中间运算结果、变量等
* 基于寄存器的解释器：支持寄存器的指令操作，使用寄存器来保存参数、变量、中间计算结果等

通常，基于栈的虚拟机也定义了少量的寄存器，基于寄存器的虚拟机也有堆栈，其区别体现在它们提供的指令集体系。V8 虚拟机则采用了基于寄存器的设计。

### 优化编译器 TurboFan
利用 Ignition 所收集的信息，将 Bytecode 转换为优化后的机器码。当该段代码再次执行时，解释器就直接使用该机器码执行，不用再次解释。同时也会反优化解释器。

#### 反优化
优化后的 机器码 会被还原为 Bytecode，这个过程叫做反优化。这是因为 Ignition 收集的信息可能是错误的，比如函数的参数之前是整数，后来又变成了字符串。生成的 机器码 已经假定函数的参数是整数，那当然是错误的，于是需要进行 反优化。

### 解释执行
需要先将输入的源代码通过解析器编译成中间代码，之后直接使用解释器解释执行中间代码，然后直接输出结果。

### 编译执行
先将源代码转换为中间代码，然后我们的编译器再将中间代码编译成机器代码。通常编译成的机器代码是以二进制文件形式存储的，需要执行这段程序的时候直接执行二进制文件就可以了。
#### 编译执行、解释执行、即时编译
C语言编译器gcc，Java语言编译器javac。

编译执行：通过编译器将源代码编译成机器码，之后才能执行的语言。比如C语言。

解释执行：不需要预先进行编译，逐行解释执行。比如最早期的js 和 java

即时编译(JIT)：现在V8中，js这种在运行时编译代码的技术也被称为 JIT（即时编译）。

### 垃圾回收器 Orinoco
垃圾回收模块，负责将程序不再需要的内存空间回收。

## V8 怎么执行 JavaScript 代码的？
* 初始化堆栈空间，事件循环系统。
* 解析源码生成 AST 和 全局上下文（作用域），全局上下文入栈；
* 依据 AST 和作用域生成字节码；
* 解释执行字节码，遇见函数，解析函数AST，创建函数上下文（作用域），函数上下文入栈；
* 监听热点代码；
* 优化热点代码为机器代码；
* 反优化生成的机器代码。

## 解释器（Ignition）如何将 AST翻译为字节码并执行？
一份源码，直接转换成机器码，体积是很大的，非常消耗内存，V8 为了解决内存占用问题引入了字节码，先将源码转换成字节码。

V8 的字节码是对机器码的抽象，语法与汇编有些类似。可以把 V8 字节码看作一个个指令，这些指令组合到一起实现我们编写的功能，V8 定义了几百个字节码，可以在 V8 解释器的头文件中查看所有字节码。

解释器在执行字节码时，主要使用通用寄存器和累加寄存器，函数参数和局部变量都保存在通用寄存器中，累加寄存器用于保存中间结果。字节码来控制各种寄存器的执行，最终返回输出。

## 优化编译器（TurboFan）的工作原理
如果函数没有被调用，则 V8 不会去编译它。如果函数只被调用 1 次，则 Ignition 将其编译 Bytecode 就直接解释执行了。TurboFan 不会进行优化编译，因为它需要 Ignition 收集函数执行时的类型信息。这就要求函数至少需要执行 1 次，TurboFan 才有可能进行优化编译。

如果函数被调用多次，则它有可能会被识别为热点函数，且 Ignition 收集的类型信息证明可以进行优化编译的话，这时 TurboFan 则会将 Bytecode 编译为 Optimized Machine Code（已优化的机器码），以提高代码的执行性能。

V8 为了提升 JavaScript 的执行性能，在优化编译方面做了很多工作，其中最主要有内联和逃逸分析两种算法。

## V8 调试  v8-debug / d8
v8-debug / d8 是一个非常有用的调试工具，我们可以使用它来查看 V8 在执行 JavaScript 过程中的各种中间数据，比如作用域、AST、字节码、优化的二进制代码、垃圾回收的状态等等。

### 通过 jsvu 安装 v8-debug
jsvu 是 JavaScript 引擎版本管理工具，可以安装不同的js引擎。

```
npm install -g jsvu
```
执行jsvu，根据提示安装V8 和 V8 debug包，安装后将在用户目录下的 `.jsvu` 文件夹下
```
jsvu
```
### 用法
先将命令输出到一个文本中，方便查阅
```js
~/.jsvu/v8-debug --help >> v8-debug-help.txt
```

比如有一个js文件
```js
function add(a, b) {
  return a + b;
}
for (i = 0; i < 100000; i++) {
  add(i, i + 1);
}
```
* --print-scopes // 打印作用域信息
* --print-ast // 打印AST语法树
* --print-bytecode // 打印生成的字节码
* --print-opt-source // 打印优化后的源码
* --print-opt-code // 打印优化后的汇编代码
* --trace-gc // 打印内存回收信息

## 执行上下文，作用域
### 执行上下文
执行上下文其实就是当代码执行时的context，包含词法环境，变量环境，以及this的指向。
```js
ExecutionContext = {
    // this
    ThisBinding = <this value>
    //词法环境
    LexicalEnvironment = { ... },
    //变量环境
    VariableEnvironment = { ... },
}
```
#### 词法环境
词法环境是一种规范类型，基于 ECMAScript 代码的词法嵌套结构来定义标识符和具体变量和函数的关联。一个词法环境由环境记录器和一个可能的引用外部词法环境的引用组成。
* 词法环境有两种类型：全局环境，函数环境
* 环境记录器是存储let const 类型的变量和函数声明等。
* 外部环境的引用意味着它可以访问其父级词法环境。全局环境的外部环境引用是 null。

抽象地讲，词法环境在伪代码中看起来像这样：
```js
// 全局环境
GlobalExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      // 在这里绑定标识符
    }
    outer: <null>
  }
}

FunctionExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      // 在这里绑定标识符
    }
    outer: <Global or outer function environment reference>
  }
}
```
#### 变量环境
它同样是一个词法环境，只用来存储var类型的变量或者函数声明

### 作用域
词法环境和变量环境组成了作用域，在代码执行过程中，会从这些环境中寻找对应的变量，找不到就从父级环境找，形成作用域链。
